Compulsory: Pentru primul subpunct am afisat pe ecran mesajul "Hello world", am folosit ..println pentru a trece la randul urmator.Apoi am declarat un array de string-uri numit "languages"si l-am initializat cu valorile din cerinta.La subpunctul 3 am folosit functia math.random care genereaza random un numar intre 0 si 1 si l-am inmultit cu 1.000.000 pentru a genera numere intre 0 si 999.999. Acest numar l-am stocat intr-un integer n. La subpunctul 4 am aplicat operatii aritmetice cu aceasta variabila n. La subpunctul 5 am folosit doua structuri repetitive while, imbricate, pentru a face suma cifrelor variabilei n , cat timp n-ul are mai mult de o cifra.La ultimul subpunct , am afisat pe ecran mesajul "Willy-nilly, this semester I will learn " concatenat cu languages[n], care va fi mereu JAVA.

Homework: Prima data am pus intr-o variabila timpul de start am rularii cu ajutorul metodei System.currentTimeMillis(); Am parsat argumentele si am verificat validitatea acestora, am creat un obiect mutabil nou cu stringBuilder pentru a stoca numerele k-reductibile. In a,b,k stochez argumentele date de la linia de comanda si apoi cu un for si 2 while-uri caut si identific numerele k-reductibile. La sfarsit le afisez si pun in alta variabila timpul de finish al rularii si il afisez. Timpul este afisat in milisecunde.

Bonus: Pe diagonala principala a matricii avem valoarea 0 din start. Toate nodurile sunt vecine cu nodul din centru , care este notat cu n , deci pe linia n si coloana n ,in afara de elementul de pe diagonala principala, avem 1. Avem doua cazuri speciale, pentru i=1 , cand in matricea de adiacenta avem 1 pe pozitiile [i][i+1] si [i][n-1] , adica succesor acestuia si predecesorul nodului din centru, si pentru i=n-1 avem 1 pe pozitiile [i][i-1] si [i][1] , adica predecesorul si primul nod. in cazul general avem 1 pe pozitiile [i][i+1] si [i][i-1] ,adica predecesorul si succesorul acestuia. Apoi afisez matricea finala.

Afisez primul circuit separat, reprezentat de conturul grafului, apoi plec dintr-un nod, pe care il afisez, apoi afisez centrul grafului care apare in toate circuitele grafului. Ulterior , cu doua for-uri separate , merg fie pe succesorul primului nod, fie pe predecesorul acestuia, aceste circuite fiind complementare. In for-ul pentru succesor , fac contor modulo n pentru a fi sigur ca nu il depaseste din start pe i. La final , verific daca formula este corecta comparand , formula cu numarul de circuite pe care l-am gasit.
